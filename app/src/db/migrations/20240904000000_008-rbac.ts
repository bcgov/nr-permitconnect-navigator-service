/* eslint-disable max-len */
import { v4 as uuidv4 } from 'uuid';

import stamps from '../stamps';

import type { Knex } from 'knex';
import { Action, GroupName, Initiative, Resource } from '../../utils/enums/application';

const resources = [
  {
    name: Resource.ACCESS_REQUEST
  },
  {
    name: Resource.DOCUMENT
  },
  {
    name: Resource.ENQUIRY
  },
  {
    name: Resource.NOTE
  },
  {
    name: Resource.PERMIT
  },
  {
    name: Resource.ROADMAP
  },
  {
    name: Resource.SSO
  },
  {
    name: Resource.SUBMISSION
  },
  {
    name: Resource.USER
  }
];

const actions = [
  {
    name: Action.CREATE
  },
  {
    name: Action.READ
  },
  {
    name: Action.UPDATE
  },
  {
    name: Action.DELETE
  }
];

export async function up(knex: Knex): Promise<void> {
  return (
    Promise.resolve()
      .then(() =>
        knex.schema.alterTable('user', (table) => {
          table.renameColumn('username', 'sub');
        })
      )

      // Alter public schema tables
      .then(() =>
        knex.schema.alterTable('submission', (table) => {
          // Add new columns
          table.boolean('consent_to_feedback').notNullable().defaultTo(false);
        })
      )
      // Create the access_request table
      .then(() =>
        knex.schema.createTable('access_request', (table) => {
          table.uuid('access_request_id').primary();
          table.uuid('user_id').notNullable().references('user_id').inTable('user');
          table.text('group');
          table
            .enu('status', ['Approved', 'Pending', 'Rejected'], {
              useNative: true,
              enumName: 'access_request_status_enum'
            })
            .defaultTo('Pending')
            .notNullable();
          table.boolean('grant').notNullable();
          stamps(knex, table);
        })
      )

      .then(() =>
        knex.schema.raw(`create trigger before_update_access_request_trigger
        before update on public.access_request
        for each row execute procedure public.set_updated_at();`)
      )

      .then(() =>
        knex.schema.raw(`CREATE TRIGGER audit_access_request_trigger
        AFTER UPDATE OR DELETE ON access_request
        FOR EACH ROW EXECUTE PROCEDURE audit.if_modified_func();`)
      )

      // Create schema
      .then(() => knex.schema.raw('CREATE SCHEMA IF NOT EXISTS yars'))

      // Create tables
      .then(() =>
        knex.schema.withSchema('yars').createTable('group', (table) => {
          table.specificType('group_id', 'integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY');
          table
            .uuid('initiative_id')
            .references('initiative_id')
            .inTable('public.initiative')
            .onUpdate('CASCADE')
            .onDelete('CASCADE')
            .notNullable();
          table.text('name').notNullable();
          table.text('label').notNullable();
          stamps(knex, table);
          table.unique(['initiative_id', 'name']);
        })
      )

      .then(() =>
        knex.schema.withSchema('yars').createTable('role', (table) => {
          table.specificType('role_id', 'integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY');
          table.text('name').notNullable();
          table.text('description');
          table.boolean('record_security').notNullable().defaultTo(false);
          stamps(knex, table);
          table.unique('name');
        })
      )

      .then(() =>
        knex.schema.withSchema('yars').createTable('action', (table) => {
          table.specificType('action_id', 'integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY');
          table.text('name').notNullable();
          stamps(knex, table);
          table.unique('name');
        })
      )

      .then(() =>
        knex.schema.withSchema('yars').createTable('resource', (table) => {
          table.specificType('resource_id', 'integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY');
          table.text('name').notNullable();
          stamps(knex, table);
          table.unique('name');
        })
      )

      .then(() =>
        knex.schema.withSchema('yars').createTable('policy', (table) => {
          table.specificType('policy_id', 'integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY');
          table
            .integer('resource_id')
            .notNullable()
            .references('resource_id')
            .inTable('yars.resource')
            .onUpdate('CASCADE')
            .onDelete('CASCADE');
          table
            .integer('action_id')
            .notNullable()
            .references('action_id')
            .inTable('yars.action')
            .onUpdate('CASCADE')
            .onDelete('CASCADE');
          stamps(knex, table);
          table.unique(['resource_id', 'action_id']);
        })
      )

      .then(() =>
        knex.schema.withSchema('yars').createTable('attribute', (table) => {
          table.specificType('attribute_id', 'integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY');
          table.text('name').notNullable();
          table.text('description');
          stamps(knex, table);
          table.unique('name');
        })
      )

      .then(() =>
        knex.schema.withSchema('yars').createTable('group_role', (table) => {
          table.primary(['group_id', 'role_id']);
          table
            .integer('group_id')
            .notNullable()
            .references('group_id')
            .inTable('yars.group')
            .onUpdate('CASCADE')
            .onDelete('CASCADE');
          table
            .integer('role_id')
            .notNullable()
            .references('role_id')
            .inTable('yars.role')
            .onUpdate('CASCADE')
            .onDelete('CASCADE');
          stamps(knex, table);
        })
      )

      .then(() =>
        knex.schema.withSchema('yars').createTable('role_policy', (table) => {
          table.primary(['role_id', 'policy_id']);
          table
            .integer('role_id')
            .notNullable()
            .references('role_id')
            .inTable('yars.role')
            .onUpdate('CASCADE')
            .onDelete('CASCADE');
          table
            .integer('policy_id')
            .notNullable()
            .references('policy_id')
            .inTable('yars.policy')
            .onUpdate('CASCADE')
            .onDelete('CASCADE');
          stamps(knex, table);
        })
      )

      .then(() =>
        knex.schema.withSchema('yars').createTable('policy_attribute', (table) => {
          table.primary(['policy_id', 'attribute_id']);
          table
            .integer('policy_id')
            .notNullable()
            .references('policy_id')
            .inTable('yars.policy')
            .onUpdate('CASCADE')
            .onDelete('CASCADE');
          table
            .integer('attribute_id')
            .notNullable()
            .references('attribute_id')
            .inTable('yars.attribute')
            .onUpdate('CASCADE')
            .onDelete('CASCADE');
          stamps(knex, table);
        })
      )

      .then(() =>
        knex.schema.withSchema('yars').createTable('attribute_group', (table) => {
          table.primary(['attribute_id', 'group_id']);
          table
            .integer('attribute_id')
            .notNullable()
            .references('attribute_id')
            .inTable('yars.attribute')
            .onUpdate('CASCADE')
            .onDelete('CASCADE');
          table
            .integer('group_id')
            .notNullable()
            .references('group_id')
            .inTable('yars.group')
            .onUpdate('CASCADE')
            .onDelete('CASCADE');
          stamps(knex, table);
        })
      )

      .then(() =>
        knex.schema.withSchema('yars').createTable('subject_group', (table) => {
          table.primary(['sub', 'group_id']);
          table.text('sub').notNullable();
          table
            .integer('group_id')
            .notNullable()
            .references('group_id')
            .inTable('yars.group')
            .onUpdate('CASCADE')
            .onDelete('CASCADE');
          stamps(knex, table);
        })
      )

      // Create before update triggers
      .then(() =>
        knex.schema.raw(`CREATE TRIGGER before_update_group_trigger
          BEFORE UPDATE ON yars."group"
          FOR EACH ROW EXECUTE PROCEDURE public.set_updated_at();`)
      )

      .then(() =>
        knex.schema.raw(`CREATE TRIGGER before_update_role_trigger
          BEFORE UPDATE ON yars."role"
          FOR EACH ROW EXECUTE PROCEDURE public.set_updated_at();`)
      )

      .then(() =>
        knex.schema.raw(`CREATE TRIGGER before_update_action_trigger
          BEFORE UPDATE ON yars."action"
          FOR EACH ROW EXECUTE PROCEDURE public.set_updated_at();`)
      )

      .then(() =>
        knex.schema.raw(`CREATE TRIGGER before_update_resource_trigger
          BEFORE UPDATE ON yars."resource"
          FOR EACH ROW EXECUTE PROCEDURE public.set_updated_at();`)
      )

      .then(() =>
        knex.schema.raw(`CREATE TRIGGER before_update_policy_trigger
          BEFORE UPDATE ON yars."policy"
          FOR EACH ROW EXECUTE PROCEDURE public.set_updated_at();`)
      )

      .then(() =>
        knex.schema.raw(`CREATE TRIGGER before_update_attribute_trigger
          BEFORE UPDATE ON yars."attribute"
          FOR EACH ROW EXECUTE PROCEDURE public.set_updated_at();`)
      )

      .then(() =>
        knex.schema.raw(`CREATE TRIGGER before_update_group_role_trigger
          BEFORE UPDATE ON yars."group_role"
          FOR EACH ROW EXECUTE PROCEDURE public.set_updated_at();`)
      )

      .then(() =>
        knex.schema.raw(`CREATE TRIGGER before_update_role_policy_trigger
          BEFORE UPDATE ON yars."role_policy"
          FOR EACH ROW EXECUTE PROCEDURE public.set_updated_at();`)
      )

      .then(() =>
        knex.schema.raw(`CREATE TRIGGER before_update_policy_attribute_trigger
          BEFORE UPDATE ON yars."policy_attribute"
          FOR EACH ROW EXECUTE PROCEDURE public.set_updated_at();`)
      )

      .then(() =>
        knex.schema.raw(`CREATE TRIGGER before_update_attribute_group_trigger
          BEFORE UPDATE ON yars."attribute_group"
          FOR EACH ROW EXECUTE PROCEDURE public.set_updated_at();`)
      )

      .then(() =>
        knex.schema.raw(`CREATE TRIGGER before_update_subject_group_trigger
          BEFORE UPDATE ON yars."subject_group"
          FOR EACH ROW EXECUTE PROCEDURE public.set_updated_at();`)
      )

      // Create audit triggers
      .then(() =>
        knex.schema.raw(`CREATE TRIGGER audit_group_trigger
          AFTER UPDATE OR DELETE ON yars."group"
          FOR EACH ROW EXECUTE PROCEDURE audit.if_modified_func();`)
      )

      .then(() =>
        knex.schema.raw(`CREATE TRIGGER audit_role_trigger
          AFTER UPDATE OR DELETE ON yars."role"
          FOR EACH ROW EXECUTE PROCEDURE audit.if_modified_func();`)
      )

      .then(() =>
        knex.schema.raw(`CREATE TRIGGER audit_action_trigger
          AFTER UPDATE OR DELETE ON yars."action"
          FOR EACH ROW EXECUTE PROCEDURE audit.if_modified_func();`)
      )

      .then(() =>
        knex.schema.raw(`CREATE TRIGGER audit_resource_trigger
          AFTER UPDATE OR DELETE ON yars."resource"
          FOR EACH ROW EXECUTE PROCEDURE audit.if_modified_func();`)
      )

      .then(() =>
        knex.schema.raw(`CREATE TRIGGER audit_policy_trigger
          AFTER UPDATE OR DELETE ON yars."policy"
          FOR EACH ROW EXECUTE PROCEDURE audit.if_modified_func();`)
      )

      .then(() =>
        knex.schema.raw(`CREATE TRIGGER audit_attribute_trigger
          AFTER UPDATE OR DELETE ON yars."attribute"
          FOR EACH ROW EXECUTE PROCEDURE audit.if_modified_func();`)
      )

      .then(() =>
        knex.schema.raw(`CREATE TRIGGER audit_group_role_trigger
          AFTER UPDATE OR DELETE ON yars."group_role"
          FOR EACH ROW EXECUTE PROCEDURE audit.if_modified_func();`)
      )

      .then(() =>
        knex.schema.raw(`CREATE TRIGGER audit_role_policy_trigger
          AFTER UPDATE OR DELETE ON yars."role_policy"
          FOR EACH ROW EXECUTE PROCEDURE audit.if_modified_func();`)
      )

      .then(() =>
        knex.schema.raw(`CREATE TRIGGER audit_policy_attribute_trigger
          AFTER UPDATE OR DELETE ON yars."policy_attribute"
          FOR EACH ROW EXECUTE PROCEDURE audit.if_modified_func();`)
      )

      .then(() =>
        knex.schema.raw(`CREATE TRIGGER audit_attribute_group_trigger
          AFTER UPDATE OR DELETE ON yars."attribute_group"
          FOR EACH ROW EXECUTE PROCEDURE audit.if_modified_func();`)
      )

      .then(() =>
        knex.schema.raw(`CREATE TRIGGER audit_subject_group_trigger
          AFTER UPDATE OR DELETE ON yars."subject_group"
          FOR EACH ROW EXECUTE PROCEDURE audit.if_modified_func();`)
      )

      // Populate Baseline Data
      .then(async () => {
        const exists = await knex('initiative').where({
          code: Initiative.PCNS
        });
        if (exists.length === 0) {
          const items = [
            {
              initiative_id: uuidv4(),
              code: Initiative.PCNS,
              label: 'Permit Connect Navigator Service'
            }
          ];
          return knex('initiative').insert(items);
        }
      })

      .then(async () => {
        /*
         * Add groups
         */

        const pcns_id = knex('initiative')
          .where({
            code: Initiative.PCNS
          })
          .select('initiative_id');

        const housing_id = knex('initiative')
          .where({
            code: Initiative.HOUSING
          })
          .select('initiative_id');

        const items = [
          {
            initiative_id: pcns_id,
            name: GroupName.DEVELOPER,
            label: 'Developer'
          },
          {
            initiative_id: housing_id,
            name: GroupName.PROPONENT,
            label: 'Proponent'
          },
          {
            initiative_id: housing_id,
            name: GroupName.NAVIGATOR,
            label: 'Navigator'
          },
          {
            initiative_id: housing_id,
            name: GroupName.NAVIGATOR_READ_ONLY,
            label: 'Navigator (Read-only)'
          },
          {
            initiative_id: housing_id,
            name: GroupName.SUPERVISOR,
            label: 'Supervisor'
          },
          {
            initiative_id: housing_id,
            name: GroupName.ADMIN,
            label: 'Admin'
          }
        ];
        return knex('yars.group').insert(items);
      })

      .then(() => {
        /*
         * Add resources
         */

        return knex('yars.resource').insert(resources);
      })

      .then(() => {
        /*
         * Add actions
         */

        return knex('yars.action').insert(actions);
      })

      .then(() => {
        /*
         * Add policies
         */

        const items = [];
        for (const resource of resources) {
          for (const action of actions) {
            items.push({
              resource_id: knex('yars.resource').where({ name: resource.name }).select('resource_id'),
              action_id: knex('yars.action').where({ name: action.name }).select('action_id')
            });
          }
        }

        return knex('yars.policy').insert(items);
      })

      .then(async () => {
        /*
         * Add roles
         */

        const items: Array<{ name: string; description: string }> = [];

        const addRolesForResource = (resourceName: string) => {
          items.push(
            {
              name: `${resourceName.toUpperCase()}_CREATOR`,
              description: `Can create ${resourceName.toLowerCase()}s`
            },
            {
              name: `${resourceName.toUpperCase()}_VIEWER`,
              description: `Can view ${resourceName.toLowerCase()}s`
            },
            {
              name: `${resourceName.toUpperCase()}_EDITOR`,
              description: `Can edit ${resourceName.toLowerCase()}s`
            }
          );
        };

        for (const resource of resources) {
          addRolesForResource(resource.name);
        }

        return knex('yars.role').insert(items);
      })

      .then(async () => {
        /*
         * Add attributes
         */

        return knex('yars.attribute').insert([
          {
            name: 'scope:all'
          },
          {
            name: 'scope:self'
          }
        ]);
      })

      .then(async () => {
        /*
         * Add role to policy mappings
         */

        const policies = await knex
          .select('p.policy_id', 'r.name as resource_name', 'a.name as action_name')
          .from({ p: 'yars.policy' })
          .innerJoin({ r: 'yars.resource' }, 'p.resource_id', '=', 'r.resource_id')
          .innerJoin({ a: 'yars.action' }, 'p.action_id', '=', 'a.action_id');

        const items: Array<{ role_id: number; policy_id: number }> = [];

        const addRolePolicies = async (resourceName: string) => {
          const creatorId = await knex('yars.role')
            .where({ name: `${resourceName.toUpperCase()}_CREATOR` })
            .select('role_id');
          const viewerId = await knex('yars.role')
            .where({ name: `${resourceName.toUpperCase()}_VIEWER` })
            .select('role_id');
          const editorId = await knex('yars.role')
            .where({ name: `${resourceName.toUpperCase()}_EDITOR` })
            .select('role_id');

          const resourcePolicies = policies.filter((x) => x.resource_name === resourceName);
          items.push(
            {
              role_id: creatorId[0].role_id,
              policy_id: resourcePolicies.find((x) => x.action_name == Action.CREATE).policy_id
            },
            {
              role_id: viewerId[0].role_id,
              policy_id: resourcePolicies.find((x) => x.action_name == Action.READ).policy_id
            },
            {
              role_id: editorId[0].role_id,
              policy_id: resourcePolicies.find((x) => x.action_name == Action.UPDATE).policy_id
            },

            {
              role_id: editorId[0].role_id,
              policy_id: resourcePolicies.find((x) => x.action_name == Action.DELETE).policy_id
            }
          );
        };

        await addRolePolicies(Resource.ACCESS_REQUEST);
        await addRolePolicies(Resource.DOCUMENT);
        await addRolePolicies(Resource.ENQUIRY);
        await addRolePolicies(Resource.NOTE);
        await addRolePolicies(Resource.PERMIT);
        await addRolePolicies(Resource.ROADMAP);
        await addRolePolicies(Resource.SSO);
        await addRolePolicies(Resource.SUBMISSION);
        await addRolePolicies(Resource.USER);

        return knex('yars.role_policy').insert(items);
      })

      .then(async () => {
        /*
         * Add group to role mappings
         */

        const housing_id = knex('initiative')
          .where({
            code: Initiative.HOUSING
          })
          .select('initiative_id');

        const navigator_group_id = await knex('yars.group')
          .where({ initiative_id: housing_id, name: GroupName.NAVIGATOR })
          .select('group_id');

        const navigator_read_group_id = await knex('yars.group')
          .where({ initiative_id: housing_id, name: GroupName.NAVIGATOR_READ_ONLY })
          .select('group_id');

        const superviser_group_id = await knex('yars.group')
          .where({ initiative_id: housing_id, name: GroupName.SUPERVISOR })
          .select('group_id');

        const admin_group_id = await knex('yars.group')
          .where({ initiative_id: housing_id, name: GroupName.ADMIN })
          .select('group_id');

        const proponent_group_id = await knex('yars.group')
          .where({ initiative_id: housing_id, name: GroupName.PROPONENT })
          .select('group_id');

        const items: Array<{ group_id: number; role_id: number }> = [];

        const addResourceRoles = async (group_id: number, resourceName: Resource, actionNames: Array<Action>) => {
          if (actionNames.includes(Action.CREATE)) {
            items.push({
              group_id: group_id,
              role_id: (
                await knex('yars.role')
                  .where({ name: `${resourceName}_CREATOR` })
                  .select('role_id')
              )[0].role_id
            });
          }

          if (actionNames.includes(Action.READ)) {
            items.push({
              group_id: group_id,
              role_id: (
                await knex('yars.role')
                  .where({ name: `${resourceName}_VIEWER` })
                  .select('role_id')
              )[0].role_id
            });
          }

          if (actionNames.includes(Action.UPDATE) || actionNames.includes(Action.DELETE)) {
            items.push({
              group_id: group_id,
              role_id: (
                await knex('yars.role')
                  .where({ name: `${resourceName}_EDITOR` })
                  .select('role_id')
              )[0].role_id
            });
          }
        };

        // Note: Only UPDATE or DELETE is required to be given EDITOR role, don't include both
        // prettier-ignore
        {
          // Add all navigator role mappings
          await addResourceRoles(navigator_group_id[0].group_id, Resource.DOCUMENT, [Action.CREATE, Action.READ, Action.UPDATE]);
          await addResourceRoles(navigator_group_id[0].group_id, Resource.ENQUIRY, [Action.CREATE, Action.READ, Action.UPDATE]);
          await addResourceRoles(navigator_group_id[0].group_id, Resource.NOTE, [Action.CREATE, Action.READ, Action.UPDATE]);
          await addResourceRoles(navigator_group_id[0].group_id, Resource.PERMIT, [Action.CREATE, Action.READ, Action.UPDATE]);
          await addResourceRoles(navigator_group_id[0].group_id, Resource.ROADMAP, [Action.CREATE, Action.READ, Action.UPDATE]);
          await addResourceRoles(navigator_group_id[0].group_id, Resource.SSO, [Action.READ]);
          await addResourceRoles(navigator_group_id[0].group_id, Resource.SUBMISSION, [Action.CREATE, Action.READ, Action.UPDATE]);
          await addResourceRoles(navigator_group_id[0].group_id, Resource.USER, [Action.READ]);

          // Add all navigator read only role mappings
          await addResourceRoles(navigator_read_group_id[0].group_id, Resource.DOCUMENT, [Action.READ]);
          await addResourceRoles(navigator_read_group_id[0].group_id, Resource.ENQUIRY, [Action.READ]);
          await addResourceRoles(navigator_read_group_id[0].group_id, Resource.NOTE, [Action.READ]);
          await addResourceRoles(navigator_read_group_id[0].group_id, Resource.PERMIT, [Action.READ]);
          await addResourceRoles(navigator_read_group_id[0].group_id, Resource.ROADMAP, [Action.READ]);
          await addResourceRoles(navigator_read_group_id[0].group_id, Resource.SSO, [Action.READ]);
          await addResourceRoles(navigator_read_group_id[0].group_id, Resource.SUBMISSION, [Action.READ]);
          await addResourceRoles(navigator_read_group_id[0].group_id, Resource.USER, [Action.READ]);

          // Add all supervisor role mappings
          await addResourceRoles(superviser_group_id[0].group_id, Resource.ACCESS_REQUEST, [Action.CREATE, Action.READ]);
          await addResourceRoles(superviser_group_id[0].group_id, Resource.DOCUMENT, [Action.CREATE, Action.READ, Action.UPDATE]);
          await addResourceRoles(superviser_group_id[0].group_id, Resource.ENQUIRY, [Action.CREATE, Action.READ, Action.UPDATE]);
          await addResourceRoles(superviser_group_id[0].group_id, Resource.NOTE, [Action.CREATE, Action.READ, Action.UPDATE]);
          await addResourceRoles(superviser_group_id[0].group_id, Resource.PERMIT, [Action.CREATE, Action.READ, Action.UPDATE]);
          await addResourceRoles(superviser_group_id[0].group_id, Resource.ROADMAP, [Action.CREATE, Action.READ, Action.UPDATE]);
          await addResourceRoles(superviser_group_id[0].group_id, Resource.SSO, [Action.READ]);
          await addResourceRoles(superviser_group_id[0].group_id, Resource.SUBMISSION, [Action.CREATE, Action.READ, Action.UPDATE]);
          await addResourceRoles(superviser_group_id[0].group_id, Resource.USER, [Action.READ]);

          // Add all admin role mappings
          await addResourceRoles(admin_group_id[0].group_id, Resource.ACCESS_REQUEST, [Action.CREATE, Action.READ, Action.UPDATE]);
          await addResourceRoles(admin_group_id[0].group_id, Resource.DOCUMENT, [Action.READ]);
          await addResourceRoles(admin_group_id[0].group_id, Resource.ENQUIRY, [Action.READ]);
          await addResourceRoles(admin_group_id[0].group_id, Resource.NOTE, [Action.READ]);
          await addResourceRoles(admin_group_id[0].group_id, Resource.PERMIT, [Action.READ]);
          await addResourceRoles(admin_group_id[0].group_id, Resource.ROADMAP, [Action.READ]);
          await addResourceRoles(admin_group_id[0].group_id, Resource.SSO, [Action.READ]);
          await addResourceRoles(admin_group_id[0].group_id, Resource.SUBMISSION, [Action.READ]);
          await addResourceRoles(admin_group_id[0].group_id, Resource.USER, [Action.CREATE, Action.READ, Action.UPDATE]);

          // Add all proponent role mappings
          await addResourceRoles(proponent_group_id[0].group_id, Resource.DOCUMENT, [Action.CREATE, Action.READ, Action.UPDATE]);
          await addResourceRoles(proponent_group_id[0].group_id, Resource.ENQUIRY, [Action.CREATE, Action.READ, Action.UPDATE]);
          await addResourceRoles(proponent_group_id[0].group_id, Resource.NOTE, [Action.CREATE, Action.READ, Action.UPDATE]);
          await addResourceRoles(proponent_group_id[0].group_id, Resource.PERMIT, [Action.CREATE, Action.READ, Action.UPDATE]);
          await addResourceRoles(proponent_group_id[0].group_id, Resource.SUBMISSION, [Action.CREATE, Action.READ, Action.UPDATE]);
        }
        return knex('yars.group_role').insert(items);
      })

      .then(async () => {
        /*
         * Attach attributes to all non CREATE policies
         */

        const action_create_id = await knex('yars.action').where({ name: Action.CREATE }).select('action_id');

        const scopeAllId = await knex('yars.attribute').where({ name: 'scope:all' }).select('attribute_id');
        const scopeSelfId = await knex('yars.attribute').where({ name: 'scope:self' }).select('attribute_id');

        const policies = await knex('yars.policy')
          .whereNot({ action_id: action_create_id[0].action_id })
          .select('policy_id');

        const items: Array<{ policy_id: number; attribute_id: number }> = [];

        for (const policy of policies) {
          items.push({ policy_id: policy.policy_id, attribute_id: scopeAllId[0].attribute_id });
          items.push({ policy_id: policy.policy_id, attribute_id: scopeSelfId[0].attribute_id });
        }

        return knex('yars.policy_attribute').insert(items);
      })

      .then(async () => {
        /*
         * Attach scopes to the proper groups
         */

        const housing_id = knex('initiative')
          .where({
            code: Initiative.HOUSING
          })
          .select('initiative_id');

        const navigator_group_id = await knex('yars.group')
          .where({ initiative_id: housing_id, name: GroupName.NAVIGATOR })
          .select('group_id');

        const navigator_read_group_id = await knex('yars.group')
          .where({ initiative_id: housing_id, name: GroupName.NAVIGATOR_READ_ONLY })
          .select('group_id');

        const superviser_group_id = await knex('yars.group')
          .where({ initiative_id: housing_id, name: GroupName.SUPERVISOR })
          .select('group_id');

        const admin_group_id = await knex('yars.group')
          .where({ initiative_id: housing_id, name: GroupName.ADMIN })
          .select('group_id');

        const proponent_group_id = await knex('yars.group')
          .where({ initiative_id: housing_id, name: GroupName.PROPONENT })
          .select('group_id');

        return knex('yars.attribute_group').insert([
          {
            attribute_id: (await knex('yars.attribute').where({ name: 'scope:all' }).select('attribute_id'))[0]
              .attribute_id,
            group_id: navigator_group_id[0].group_id
          },
          {
            attribute_id: (await knex('yars.attribute').where({ name: 'scope:all' }).select('attribute_id'))[0]
              .attribute_id,
            group_id: navigator_read_group_id[0].group_id
          },
          {
            attribute_id: (await knex('yars.attribute').where({ name: 'scope:all' }).select('attribute_id'))[0]
              .attribute_id,
            group_id: superviser_group_id[0].group_id
          },
          {
            attribute_id: (await knex('yars.attribute').where({ name: 'scope:all' }).select('attribute_id'))[0]
              .attribute_id,
            group_id: admin_group_id[0].group_id
          },
          {
            attribute_id: (await knex('yars.attribute').where({ name: 'scope:self' }).select('attribute_id'))[0]
              .attribute_id,
            group_id: proponent_group_id[0].group_id
          }
        ]);
      })

      .then(async () => {
        await knex.raw(`create view yars.group_role_policy_vw as select
          row_number() OVER (),
          yars.group.group_id,
          public.initiative.code as initiative_code,
          yars.group.name as group_name,
          yars.role.name as role_name,
          yars.policy.policy_id as policy_id,
          yars.resource.name as resource_name,
          yars.action.name as action_name
        from yars.group
        inner join public.initiative on yars.group.initiative_id = public.initiative.initiative_id
        inner join yars.group_role on yars.group_role.group_id = yars.group.group_id
        inner join yars.role on yars.role.role_id = yars.group_role.role_id
        inner join yars.role_policy on yars.role_policy.role_id = yars.role.role_id
        inner join yars.policy on yars.policy.policy_id = yars.role_policy.policy_id
        inner join yars.resource on resource.resource_id = yars.policy.resource_id
        inner join yars.action on yars.action.action_id = yars.policy.action_id;`);
      })

      // Drop public schema functions
      .then(() =>
        knex.schema.raw(`drop function public.get_activity_statistics(
                         date_from text,
                         date_to text,
                         month_year text,
                         user_id uuid
                        )`)
      )

      // Create public schema functions
      .then(() =>
        knex.schema.raw(`create or replace function public.get_activity_statistics(
        date_from text,
        date_to text,
        month_year text,
        user_id uuid
      )
      returns table (
        total_submissions bigint,
        total_submissions_between bigint,
        total_submissions_monthyear bigint,
        total_submissions_assignedto bigint,
        intake_submitted bigint,
        intake_assigned bigint,
        intake_completed bigint,
        state_new bigint,
        state_inprogress bigint,
        state_delayed bigint,
        state_completed bigint,
        supported_bc bigint,
        supported_indigenous bigint,
        supported_non_profit bigint,
        supported_housing_coop bigint,
        waiting_on bigint,
        queue_1 bigint,
        queue_2 bigint,
        queue_3 bigint,
        escalation bigint,
        general_enquiry bigint,
        guidance bigint,
        inapplicable bigint,
        status_request bigint,
        multi_permits_needed bigint
      )
      language plpgsql
      as $$
      begin
          return query
          with submission_counts as (
            select
              count(*) as submission_count,
              (select count(*) from public.submission where "submitted_at" between cast(date_from as timestamp) and cast(date_to as timestamp)) as submission_count_between,
              (select count(*) from public.submission where extract(month from cast(month_year as timestamp)) = extract(month from "submitted_at") and extract(year from cast(month_year as timestamp)) = extract(year from "submitted_at")) as submission_count_monthyear,
              (select count(*) from public.submission where "assigned_user_id" = user_id) as submission_count_assignedto,
              count(*) filter (where s."intake_status" = 'Submitted') as intake_submitted_submission_count,
              count(*) filter (where s."intake_status" = 'Assigned') as intake_assigned_submission_count,
              count(*) filter (where s."intake_status" = 'Completed') as intake_completed_submission_count,
              count(*) filter (where s."application_status" = 'New') as state_new_submission_count,
              count(*) filter (where s."application_status" = 'In Progress') as state_inprogress_submission_count,
              count(*) filter (where s."application_status" = 'Delayed') as state_delayed_submission_count,
              count(*) filter (where s."application_status" = 'Completed') as state_completed_submission_count,
              count(*) filter (where s."financially_supported_bc" = 'Yes') as supported_bc_submission_count,
              count(*) filter (where s."financially_supported_indigenous" = 'Yes') as supported_indigenous_submission_count,
              count(*) filter (where s."financially_supported_non_profit" = 'Yes') as supported_non_profit_submission_count,
              count(*) filter (where s."financially_supported_housing_coop" = 'Yes') as supported_housing_coop_submission_count,
              count(*) filter (where s."waiting_on" is not null) as waiting_on_submission_count,
              count(*) filter (where s."queue_priority" = 1) as queue_1_submission_count,
              count(*) filter (where s."queue_priority" = 2) as queue_2_submission_count,
              count(*) filter (where s."queue_priority" = 3) as queue_3_submission_count,
              count(*) filter (where s."submission_type" = 'Guidance') as guidance_submission_count,
              count(*) filter (where s."submission_type" = 'Inapplicable') as inapplicable_submission_count,
              count(distinct s.activity_id) filter (where permit_counts.permit_count > 1) as multi_permits_needed
            from public.submission s
            join public.activity a on s.activity_id = a.activity_id
            left join (
                      select p.activity_id, count(*) as permit_count
                      from public.permit p
                      where p.needed = 'Yes'
                      group by p.activity_id
                      ) permit_counts on permit_counts.activity_id = s.activity_id
            where a.is_deleted = false
            ),
            enquiry_counts as (
              select
              count(*) as enquiry_count,
              (select count(*) from public.enquiry where "submitted_at" between cast(date_from as timestamp) and cast(date_to as timestamp)) as enquiry_count_between,
              (select count(*) from public.enquiry where extract(month from cast(month_year as timestamp)) = extract(month from "submitted_at") and extract(year from cast(month_year as timestamp)) = extract(year from "submitted_at")) as enquiry_count_monthyear,
              (select count(*) from public.enquiry where "assigned_user_id" = user_id) as enquiry_count_assignedto,
              count(*) filter (where e."intake_status" = 'Submitted') as intake_submitted_enquiry_count,
              count(*) filter (where e."intake_status" = 'Assigned') as intake_assigned_enquiry_count,
              count(*) filter (where e."intake_status" = 'Completed') as intake_completed_enquiry_count,
              count(*) filter (where e."waiting_on" is not null) waiting_on_enquiry_count,
              count(*) filter (where e."enquiry_type" = 'Escalation') escalation_enquiry_count,
              count(*) filter (where e."enquiry_type" = 'General enquiry') general_enquiry_count,
              count(*) filter (where e."enquiry_type" = 'Inapplicable') as inapplicable_enquiry_count,
              count(*) filter (where e."enquiry_type" = 'Status request') as status_request_enquiry_count
            from public.enquiry e
            join public.activity a on e.activity_id = a.activity_id
            where a.is_deleted = false)
      select
          (submission_counts.submission_count + enquiry_counts.enquiry_count) AS total_submissions,
          (submission_counts.submission_count_between + enquiry_counts.enquiry_count_between) AS total_submissions_between,
          (submission_counts.submission_count_monthyear + enquiry_counts.enquiry_count_monthyear) AS total_submissions_monthyear,
          (submission_counts.submission_count_assignedto + enquiry_counts.enquiry_count_assignedto) AS total_submissions_assignedto,
          (submission_counts.intake_submitted_submission_count + enquiry_counts.intake_submitted_enquiry_count) AS intake_submitted,
          (submission_counts.intake_assigned_submission_count + enquiry_counts.intake_assigned_enquiry_count) AS intake_assigned,
          (submission_counts.intake_completed_submission_count + enquiry_counts.intake_completed_enquiry_count) AS intake_completed,
          (submission_counts.state_new_submission_count) AS state_new,
          (submission_counts.state_inprogress_submission_count) AS state_inprogress,
          (submission_counts.state_delayed_submission_count) AS state_delayed,
          (submission_counts.state_completed_submission_count) AS state_completed,
          (submission_counts.supported_bc_submission_count) AS supported_bc,
          (submission_counts.supported_indigenous_submission_count) AS supported_indigenous,
          (submission_counts.supported_non_profit_submission_count) AS supported_non_profit,
          (submission_counts.supported_housing_coop_submission_count) AS supported_housing_coop,
          (submission_counts.waiting_on_submission_count + enquiry_counts.waiting_on_enquiry_count) AS waiting_on,
          (submission_counts.queue_1_submission_count) AS queue_1,
          (submission_counts.queue_2_submission_count) AS queue_2,
          (submission_counts.queue_3_submission_count) AS queue_3,
          (enquiry_counts.escalation_enquiry_count) AS escalation,
          (enquiry_counts.general_enquiry_count) AS general_enquiry,
          (submission_counts.guidance_submission_count) AS guidance,
          (submission_counts.inapplicable_submission_count + enquiry_counts.inapplicable_enquiry_count) AS inapplicable,
          (enquiry_counts.status_request_enquiry_count) AS status_request,
          (submission_counts.multi_permits_needed) AS multi_permits_needed
      from submission_counts, enquiry_counts;
      end; $$`)
      )
  );
}

export async function down(knex: Knex): Promise<void> {
  return (
    Promise.resolve()

      // Drop public schema functions
      .then(() =>
        knex.schema.raw(`drop function public.get_activity_statistics(
                         date_from text,
                         date_to text,
                         month_year text,
                         user_id uuid
                        )`)
      )

      // Create public schema functions
      .then(() =>
        knex.schema.raw(`create or replace function public.get_activity_statistics(
      date_from text,
      date_to text,
      month_year text,
      user_id uuid
    )
    returns table (
      total_submissions bigint,
      total_submissions_between bigint,
      total_submissions_monthyear bigint,
      total_submissions_assignedto bigint,
      intake_submitted bigint,
      intake_assigned bigint,
      intake_completed bigint,
      state_new bigint,
      state_inprogress bigint,
      state_delayed bigint,
      state_completed bigint,
      supported_bc bigint,
      supported_indigenous bigint,
      supported_non_profit bigint,
      supported_housing_coop bigint,
      waiting_on bigint,
      queue_1 bigint,
      queue_2 bigint,
      queue_3 bigint,
      escalation bigint,
      general_enquiry bigint,
      guidance bigint,
      inapplicable bigint,
      status_request bigint
    )
    language plpgsql
    as $$
    begin
        return query
        with submission_counts as (
          select
            count(*) as submission_count,
            (select count(*) from public.submission where "submitted_at" between cast(date_from as timestamp) and cast(date_to as timestamp)) as submission_count_between,
            (select count(*) from public.submission where extract(month from cast(month_year as timestamp)) = extract(month from "submitted_at") and extract(year from cast(month_year as timestamp)) = extract(year from "submitted_at")) as submission_count_monthyear,
            (select count(*) from public.submission where "assigned_user_id" = user_id) as submission_count_assignedto,
            count(*) filter (where s."intake_status" = 'Submitted') as intake_submitted_submission_count,
            count(*) filter (where s."intake_status" = 'Assigned') as intake_assigned_submission_count,
            count(*) filter (where s."intake_status" = 'Completed') as intake_completed_submission_count,
            count(*) filter (where s."application_status" = 'New') as state_new_submission_count,
            count(*) filter (where s."application_status" = 'In Progress') as state_inprogress_submission_count,
            count(*) filter (where s."application_status" = 'Delayed') as state_delayed_submission_count,
            count(*) filter (where s."application_status" = 'Completed') as state_completed_submission_count,
            count(*) filter (where s."financially_supported_bc" = 'Yes') as supported_bc_submission_count,
            count(*) filter (where s."financially_supported_indigenous" = 'Yes') as supported_indigenous_submission_count,
            count(*) filter (where s."financially_supported_non_profit" = 'Yes') as supported_non_profit_submission_count,
            count(*) filter (where s."financially_supported_housing_coop" = 'Yes') as supported_housing_coop_submission_count,
            count(*) filter (where s."waiting_on" is not null) as waiting_on_submission_count,
            count(*) filter (where s."queue_priority" = 1) as queue_1_submission_count,
            count(*) filter (where s."queue_priority" = 2) as queue_2_submission_count,
            count(*) filter (where s."queue_priority" = 3) as queue_3_submission_count,
            count(*) filter (where s."submission_type" = 'Guidance') as guidance_submission_count,
            count(*) filter (where s."submission_type" = 'Inapplicable') as inapplicable_submission_count
          from public.submission s
          join public.activity a on s.activity_id = a.activity_id
          where a.is_deleted = false
          ),
          enquiry_counts as (
            select
            count(*) as enquiry_count,
            (select count(*) from public.enquiry where "submitted_at" between cast(date_from as timestamp) and cast(date_to as timestamp)) as enquiry_count_between,
            (select count(*) from public.enquiry where extract(month from cast(month_year as timestamp)) = extract(month from "submitted_at") and extract(year from cast(month_year as timestamp)) = extract(year from "submitted_at")) as enquiry_count_monthyear,
            (select count(*) from public.enquiry where "assigned_user_id" = user_id) as enquiry_count_assignedto,
            count(*) filter (where e."intake_status" = 'Submitted') as intake_submitted_enquiry_count,
            count(*) filter (where e."intake_status" = 'Assigned') as intake_assigned_enquiry_count,
            count(*) filter (where e."intake_status" = 'Completed') as intake_completed_enquiry_count,
            count(*) filter (where e."waiting_on" is not null) waiting_on_enquiry_count,
            count(*) filter (where e."enquiry_type" = 'Escalation') escalation_enquiry_count,
            count(*) filter (where e."enquiry_type" = 'General enquiry') general_enquiry_count,
            count(*) filter (where e."enquiry_type" = 'Inapplicable') as inapplicable_enquiry_count,
            count(*) filter (where e."enquiry_type" = 'Status request') as status_request_enquiry_count
          from public.enquiry e
          join public.activity a on e.activity_id = a.activity_id
          where a.is_deleted = false)
    select
        (submission_counts.submission_count + enquiry_counts.enquiry_count) AS total_submissions,
        (submission_counts.submission_count_between + enquiry_counts.enquiry_count_between) AS total_submissions_between,
        (submission_counts.submission_count_monthyear + enquiry_counts.enquiry_count_monthyear) AS total_submissions_monthyear,
        (submission_counts.submission_count_assignedto + enquiry_counts.enquiry_count_assignedto) AS total_submissions_assignedto,
        (submission_counts.intake_submitted_submission_count + enquiry_counts.intake_submitted_enquiry_count) AS intake_submitted,
        (submission_counts.intake_assigned_submission_count + enquiry_counts.intake_assigned_enquiry_count) AS intake_assigned,
        (submission_counts.intake_completed_submission_count + enquiry_counts.intake_completed_enquiry_count) AS intake_completed,
        (submission_counts.state_new_submission_count) AS state_new,
        (submission_counts.state_inprogress_submission_count) AS state_inprogress,
        (submission_counts.state_delayed_submission_count) AS state_delayed,
        (submission_counts.state_completed_submission_count) AS state_completed,
        (submission_counts.supported_bc_submission_count) AS supported_bc,
        (submission_counts.supported_indigenous_submission_count) AS supported_indigenous,
        (submission_counts.supported_non_profit_submission_count) AS supported_non_profit,
        (submission_counts.supported_housing_coop_submission_count) AS supported_housing_coop,
        (submission_counts.waiting_on_submission_count + enquiry_counts.waiting_on_enquiry_count) AS waiting_on,
        (submission_counts.queue_1_submission_count) AS queue_1,
        (submission_counts.queue_2_submission_count) AS queue_2,
        (submission_counts.queue_3_submission_count) AS queue_3,
        (enquiry_counts.escalation_enquiry_count) AS escalation,
        (enquiry_counts.general_enquiry_count) AS general_enquiry,
        (submission_counts.guidance_submission_count) AS guidance,
        (submission_counts.inapplicable_submission_count + enquiry_counts.inapplicable_enquiry_count) AS inapplicable,
        (enquiry_counts.status_request_enquiry_count) AS status_request
    from submission_counts, enquiry_counts;
    end; $$`)
      )

      // Drop yars views
      .then(() => knex.schema.withSchema('yars').dropViewIfExists('group_role_policy_vw'))

      // Drop yars audit triggers
      .then(() => knex.schema.raw('DROP TRIGGER IF EXISTS audit_subject_group_trigger ON yars."subject_group"'))
      .then(() => knex.schema.raw('DROP TRIGGER IF EXISTS audit_attribute_group_trigger ON yars."attribute_group"'))
      .then(() =>
        knex.schema.raw('DROP TRIGGER IF EXISTS audit_role_policy_attribute_trigger ON yars."policy_attribute"')
      )
      .then(() => knex.schema.raw('DROP TRIGGER IF EXISTS audit_role_policy_trigger ON yars."role_policy"'))
      .then(() => knex.schema.raw('DROP TRIGGER IF EXISTS audit_group_role_trigger ON yars."group_role"'))
      .then(() => knex.schema.raw('DROP TRIGGER IF EXISTS audit_attribute_trigger ON yars."attribute"'))
      .then(() => knex.schema.raw('DROP TRIGGER IF EXISTS audit_policy_trigger ON yars."policy"'))
      .then(() => knex.schema.raw('DROP TRIGGER IF EXISTS audit_resource_trigger ON yars."resource"'))
      .then(() => knex.schema.raw('DROP TRIGGER IF EXISTS audit_action_trigger ON yars."action"'))
      .then(() => knex.schema.raw('DROP TRIGGER IF EXISTS audit_role_trigger ON yars."role"'))
      .then(() => knex.schema.raw('DROP TRIGGER IF EXISTS audit_group_trigger ON yars."group"'))

      // Drop yars table triggers
      .then(() => knex.schema.raw('DROP TRIGGER IF EXISTS before_update_subject_group_trigger ON yars."subject_group"'))
      .then(() =>
        knex.schema.raw('DROP TRIGGER IF EXISTS before_update_attribute_group_trigger ON yars."attribute_group"')
      )
      .then(() =>
        knex.schema.raw('DROP TRIGGER IF EXISTS before_update_policy_attribute_trigger ON yars."policy_attribute"')
      )
      .then(() => knex.schema.raw('DROP TRIGGER IF EXISTS before_update_role_policy_trigger ON yars."role_policy"'))
      .then(() => knex.schema.raw('DROP TRIGGER IF EXISTS before_update_group_role_trigger ON yars."group_role"'))
      .then(() => knex.schema.raw('DROP TRIGGER IF EXISTS before_update_attribute_trigger ON yars."attribute"'))
      .then(() => knex.schema.raw('DROP TRIGGER IF EXISTS before_update_policy_trigger ON yars."policy"'))
      .then(() => knex.schema.raw('DROP TRIGGER IF EXISTS before_update_resource_trigger ON yars."resource"'))
      .then(() => knex.schema.raw('DROP TRIGGER IF EXISTS before_update_action_trigger ON yars."action"'))
      .then(() => knex.schema.raw('DROP TRIGGER IF EXISTS before_update_role_trigger ON yars."role"'))
      .then(() => knex.schema.raw('DROP TRIGGER IF EXISTS before_update_group_trigger ON yars."group"'))

      // Drop yars tables
      .then(() => knex.schema.withSchema('yars').dropTableIfExists('subject_group'))
      .then(() => knex.schema.withSchema('yars').dropTableIfExists('attribute_group'))
      .then(() => knex.schema.withSchema('yars').dropTableIfExists('policy_attribute'))
      .then(() => knex.schema.withSchema('yars').dropTableIfExists('role_policy'))
      .then(() => knex.schema.withSchema('yars').dropTableIfExists('group_role'))
      .then(() => knex.schema.withSchema('yars').dropTableIfExists('attribute'))
      .then(() => knex.schema.withSchema('yars').dropTableIfExists('policy'))
      .then(() => knex.schema.withSchema('yars').dropTableIfExists('resource'))
      .then(() => knex.schema.withSchema('yars').dropTableIfExists('action'))
      .then(() => knex.schema.withSchema('yars').dropTableIfExists('role'))
      .then(() => knex.schema.withSchema('yars').dropTableIfExists('group'))

      // Drop yars schema
      .then(() => knex.schema.dropSchemaIfExists('yars'))

      // Drop triggers
      .then(() => knex.schema.raw('DROP TRIGGER IF EXISTS before_update_access_request_trigger ON access_request'))
      .then(() => knex.schema.raw('DROP TRIGGER IF EXISTS audit_access_request_trigger ON access_request'))
      // Drop the access_request table
      .then(() => knex.schema.dropTableIfExists('access_request'))
      // Drop the access_request_status_enum type
      .then(() => knex.schema.raw('DROP TYPE IF EXISTS access_request_status_enum'))
      // Drop consent_to_feedback column from submission table
      .then(() =>
        knex.schema.alterTable('submission', (table) => {
          table.dropColumn('consent_to_feedback');
        })
      )

      .then(() =>
        knex.schema.alterTable('user', (table) => {
          table.renameColumn('sub', 'username');
        })
      )
  );
}
